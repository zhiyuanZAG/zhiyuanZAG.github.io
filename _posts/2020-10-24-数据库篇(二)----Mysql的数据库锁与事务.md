

## 一、 导引

​		在上一篇博文中，我们提到了InnoDb支持表级锁、行级锁，而MyISAMysql只支持表级锁。本文主要介绍了Mysql数据库的锁机制及事务相关的知识。





## 二、数据库锁

​		相较于其他的数据库，Mysql数据库不同的存储引擎对应了不同的锁机制，从**加锁的力度**来划分，Mysql大致可以分为以下两种锁：

* 行级锁：当一条数据库执行语句需要操作一条或者多条数据时，只对需要操作的数据加锁，其余操作无法对当前语句操作的数据进行修改，但是可以对其他数据修改；

  > 行级锁的开销大，加锁慢；可能会出现死锁；锁定力度最小，发生锁冲突的概率最低，并发程度最高。

* 表级锁：当一条数据库执行语句需要操作一条或者多条数据时，对整张表的数据加锁，其余操作无法对表内数据进行更改，必须等待该语句执行完毕释放掉表锁后，才能对表内数据进行操作。

  > 表级锁的开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突的概率最高，并发程度最低。



​		因为Mysql数据库的行级锁是通过索引上的索引项来实现的，因此只有一个聚簇索引的IndoDB的存储引擎支持行级锁，而MYISAM因为所有的索引都是聚簇索引，所以MYISAM存储引擎不支持行级锁，只能加表级锁。同时也是因为这个原因，我们在使用InnoDB的数据库时要注意：**只有通过索引条件检索数据，InnoDB才会使用行级锁，否则InnoDB将使用表级锁**。



​	在InnoDB引擎下，Mysql依据**锁的开放程度**，分别实现了如下两种不同的锁：

* 共享锁（s）：当对某一行或者某一张表添加共享锁以后，其他任意操作语句仍然可以对改行或者该表添加共享锁，但是不支持添加排它锁。
* 排它锁（X）：当对某一行或者某一张表添加排它锁之后，其他任意操作语句对该数据的读或者写都是不允许的。

> 注意：对于update、delete和insert语句，InnoDB会自动给设计的数据集添加排它锁（X）；对于普通的select语句，InnoDB会自动给涉及的数据集添加共享锁（s）；但是我们可以在sql中通过事务显式的给数据集添加共享锁或者排它锁：
>
> * 共享锁（S）：select * from table_name where ... LOCK IN SHARE MODE;
> * 排它锁（X）：select * from table_name where ... for update；
>
> 通过LOCK IN SHARE MODE显式的获取到共享锁，主要是用在需要数据依存关系时确认某一条记录是否存在，并确保没有其他事务对该记录进行update或者delete操作。但是如果当前事务也需要对其进行更新操作，则很有可能造成死锁。如果存在需要对锁定行的数据进行更新操作的场景，应该使用 for update的方式获取到排它锁。



## 三、Mysql的事务机制（**Transaction**）

### 1. 事务的属性

之前我们说过，InnoDB的存储引擎引入支持了事务机制：

> 事务即是指应用程序执行过程中的一系列严密的操作，要么操作都成功，要么操作失败后，所有的操作都进行回滚。事务是数据库的逻辑处理单位。

​	事务具有四种属性，通常称为事务的ACID属性：

* **原子性**（Actomicity）：一个事务中包含的所有操作，要么都成功，要么全部都不执行；
* **一致性**（Consistent）：事务开始和完成时，数据都必须保持一致状态。也即是说所有相关的数据规则都必须应用于事务的修改以保持完整性；当事务结束时，所有的内部数据结构（如B树索引或者双向链表）也都必须是正确的。
* **隔离性**（Isolation）：多个事务并发执行时，一个事务的执行结果不应该影像其他事务的执行结果；
* **持久性**（Durable）：一个事务提交以后，它对数据做的操作应该永久的保留在数据库中。



### 2. 并发事务带来的问题

​		相较于串行处理，并发事务处理能大大提高数据库的数据处理能力，提高数据库系统的吞吐量。但是并发事务也会带来一系列问题，主要包含了以下几种情况：

* **脏读**：事务A读取到了事务B未提交的数据。如事务B正在对一条记录做修改，在其提交前，这条记录的数据就处在不一致的状态；此时，如果事务A也来读取这条记录，如果不加控制，那么事务A就能读取到B未提交的脏数据，并有可能对这个脏数据做进一步的处理，就会产生未提交的数据依赖关系，这种现象就被称为“脏读”。
* **不可重复读**：事务A多次读取同一数据集，在此期间，事务B对该部分数据做了修改操作，导致事务A多次读取的数据不统一，这种现象被称为“不可重复读”。
* **幻读**：事务A多次读取同一数据集，在此期间，事务B对该部分数据进行了增删操作，导致事务A多次读取的数据一次多，一次少，就类似产生了幻觉，这种现象被称为“幻读”。



### 3. 数据库的隔离机制

​		不同的数据库实例有着不同的引用场景，有的数据库读远远多于写，有的数据库则是写操作更加频繁，不同的应用场景对并发事务引发的问题有着不同的容忍度，而数据库通过给读写操作添加不同级别的锁这种方式，给我们提供了四种不同的隔离机制，我们可以结合数据库具体的应用场景，在保证满足我们的读写需求的前提下，选择性能最高的隔离机制：

* **读未提交**：事务A可以读取到事务B未提交的数据；

  > * 脏读+幻读+不可重复读 的问题都存在;
  >
  > * 锁力度最轻，并发性能最高;

* **读已提交**：事务A操作的数据，提交后事务B才能读取

  > * 消除了脏读，但是仍然存在**幻读+不可重复读;**
  > * 锁力度稍重，可以解决脏读的问题;
  > * 是Oracle数据库的默认隔离级别；

* **重复读**：同一个事务查询的结果都是与事务开始的时刻是一致的

  > * 消除了脏读+ 不可重复读，但是仍然存在幻读；
  > * 是InnoDB的默认隔离级别；

* **序列化**：每次读取都需要获取表级的共享锁，读写之间互相阻塞

  > * 能完全解决脏读+幻读+不可重复读;
  > * 加锁力度最重，并发性能最低，读写之间相互阻塞
  > * 每次读取都会完全阻塞写操作，仅仅适用于读操作频繁，写操作很少的情景



## 四、总结

​		本文主要介绍了Mysql的数据库锁类型与Mysql的事务机制，其中有几点需要注意：

* InnoDB的行锁是基于索引实现的，查询时只有通过索引检索数据，才能加行级锁，否则还是使用了表级锁；
* InnoDB操作时，如果要更新数据，应该申请足够级别的锁，即排它锁。而不是现申请共享锁，更新时在申请排它锁，这种操作容易导致死锁的产生；
* 注意数据库的不同隔离机制所能解决的并发事务问题，需要结合不同的应用场景，选用适合的隔离机制，在能容忍的并发事务问题前提下，尽可能提高读写并发读写性能。



​		以上即是对数据库锁及事务机制的总结，下一篇我们一起来总结一下数据库的一二级缓存及MVCC。