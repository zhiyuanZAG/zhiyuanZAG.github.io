<h1 id="数据库篇一-mysql数据库的存储结构与索引">数据库篇(一)—-Mysql数据库的存储结构与索引</h1>

<blockquote>
  <p>创建于2020年10月20日</p>
</blockquote>

<hr />

<h2 id="一导引">一、导引</h2>

<p>​		本篇博文是数据库总结内容的第一篇，主要涉及Mysql数据库的存储结构。本文的内容是基于个人的学习与理解创作，如发现错误及问题，欢迎各位指正。</p>

<h2 id="二mysql的存储结构">二、Mysql的存储结构</h2>

<h3 id="1-页">1. 页</h3>

<p>​		计算机在进行磁盘数据的读取时，默认为读取某一数据后，紧跟着大概了会再次读取数据或者该数据前后的数据。所以计算机在进行磁盘数据的读取时，会连续读取该数据周围4Kb的数据，用以减少磁盘IO，基于此种原理，数据库设计时引入了“页”的概念。</p>

<p>​		作为一款应用程序，数据库在保存数据时，是通过其独特的数据组织形式，将数据持久化到硬盘中，而<strong>Mysql保存数据的基本单位就是“页”</strong>。</p>

<p>​		Mysql会将数据存放在一个叫“页”的数据结构中，当Mysql读取某一条数据时，会将该条数据所在的页整条加载到内存中，在内存中进行遍历查找。</p>

<p>​		<strong>Mysql中“页”的大小为16Kb</strong>，数据在插入页中时，Mysql会对插入进行优化，使其按照主键排序后插入。</p>

<p>​</p>

<h3 id="2-页目录">2. 页目录</h3>

<p>​		为了提高单页内数据的查找速度，数据库给“页”中的物理数据添加目录索引，这种由页中的物理数据间次取出其引起构成的逻辑结构的目录结构叫“页目录”，示意图如下：</p>

<p><img src="https://blog-image-zhiyuan.oss-cn-beijing.aliyuncs.com/blogImage/%E9%A1%B5%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="页目录结构" /></p>

<h3 id="3-多页">3. 多页</h3>

<p>​		随着数据量的增多, 单页的存储量不足以存储，需要将单页进行横向扩展成<strong><em>多页</em></strong>，页与页之间以链表的结构连接。多页的结构示意图如下:</p>

<p><img src="https://blog-image-zhiyuan.oss-cn-beijing.aliyuncs.com/blogImage/%E5%A4%9A%E9%A1%B5%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="多页的存储结构" /></p>

<blockquote>
  <p><strong><em>注意: 当数据插入多页结构时, 并不一定是插入到新开辟的页中, 而是遍历了所有页, 按照主键排序后插入对应的位置</em></strong></p>
</blockquote>

<h3 id="4-目录页">4. 目录页</h3>

<p>​		随着存储数据量的再次增多，页的数量也逐渐增多。因为页与页之间是以链表的形式连接，数据遍历实质上就是遍历链表，数据量越大，其遍历速度越慢，因此引入<strong><em>目录页</em></strong>的概念：将不同的页，间次取出索引，形成的目录结构，就是“目录页”。</p>

<p><img src="https://blog-image-zhiyuan.oss-cn-beijing.aliyuncs.com/blogImage/%E7%9B%AE%E5%BD%95%E9%A1%B5%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="目录页的存储结构" /></p>

<blockquote>
  <p><strong><em>注意: 目录页也是页的结构，普通页中存的是项目数据，目录页中存放的是普通页的地址。</em></strong></p>
</blockquote>

<h3 id="5-b树">5. B+树</h3>

<p>​		Mysql数据的存储，是一棵意义上的B+树，树的每一个节点都是一个页，而叶子节点就是项目的数据页，除了叶子节点以外的节点，就是目录页。这棵意义上的B+树上，<strong>非叶子节点上只存放了索引，只有叶子节点存放了数据</strong>。</p>

<blockquote>
  <p>引入B+树的组织形式存放数据的优势:</p>

  <blockquote>
    <ol>
      <li>因为叶子节点上放了数据，而且有指针相连接，每个叶子节点在逻辑上是相连的，所以对应范围查找比较友好；</li>
      <li>B+树上的项目数据都存在叶子节点，所以查询速率比较稳定，一般都是经过三次查询；</li>
      <li>B+树有利于数据的扫描；</li>
      <li>B+树有利于磁盘的IO，因为其层高的不会因为数据量的增多而增加（三层的B+树大约可以存储两千万的数据量）。</li>
    </ol>
  </blockquote>
</blockquote>

<h2 id="三索引">三、索引</h2>

<p>​		为了降低因为数据量庞大而带来的整表扫描，引入了对存储项目数据的<strong>索引</strong>，用于提高查找效率；Mysql的索引是B+树的存储结构。</p>

<h3 id="1-索引的分类">1. 索引的分类</h3>

<p>​		mySql的索引分为<strong><em>聚簇索引</em></strong>和<strong><em>非聚簇索引</em></strong>两种：</p>

<ul>
  <li>
    <p>聚簇索引: 当B+树的叶子节点中包含项目数据，此类索引即是聚簇索引；</p>

    <ul>
      <li>indoDb的数据引擎中，只有一个聚簇索引，其余的皆为非聚簇索引；</li>
      <li>聚簇索引只要遍历到了对应的记录，则可以直接获取到对应的业务数据。</li>
    </ul>

    <blockquote>
      <p>注意:</p>

      <ol>
        <li>Mysql如果定义了主键，则主键即是聚簇索引；</li>
        <li>如果没有定义主键，则定义的第一个唯一非空索引就是作为聚簇索引；</li>
        <li>如果以上条件都不满足，innoDb会自动生成一个隐藏的聚簇索引；</li>
        <li>非主键索引（即非聚簇索引）存储相关键位和对应的主键值，包含了两次查找。</li>
      </ol>
    </blockquote>

    <ul>
      <li>
        <p>非聚簇索引：当B+树的叶子节点不包含项目数据，此类索引即是非聚簇索引；</p>

        <blockquote>
          <p>注意:</p>

          <ol>
            <li>非聚簇索引遍历查找时，找到的只是业务数据的引用，需要再进行一次回表（磁盘IO），才能找到对应的业务数据。</li>
          </ol>
        </blockquote>
      </li>
    </ul>
  </li>
</ul>

<h3 id="2-mysql中的常见索引">2. Mysql中的常见索引</h3>

<ul>
  <li>
    <p>主键索引</p>

    <blockquote>
      <p>在innoDb引擎下，主键索引一定是聚簇索引；</p>
    </blockquote>
  </li>
  <li>
    <p>普通索引</p>

    <blockquote>
      <p>在innoDb引擎侠，非主键索引一定是非聚簇索引；</p>
    </blockquote>
  </li>
  <li>
    <p>联合索引</p>

    <blockquote>
      <p>注意:</p>

      <ol>
        <li>
          <p>联合索引为非聚簇索引</p>
        </li>
        <li>
          <p>联合索引存在着最左匹配原则:</p>

          <blockquote>
            <p>a. 在sql语句中，= 的条件和 in 的条件可以乱序；</p>

            <p><code class="language-plaintext highlighter-rouge">示例:当sql的查询条件为a=1 and b=2 and c=3，建立的（a，b，c）的联合索引可以为任意顺序，Mysql的查询优化器会帮你优化成索引可以识别的形式。</code></p>
          </blockquote>

          <blockquote>
            <p>b. 最左前缀匹配原则，是指Mysql会一直向后匹配，知道遇到范围查询（&gt;, &lt;, between, like）就停止匹配；</p>

            <p><code class="language-plaintext highlighter-rouge">示例:当sql的查询条件为a=3 and b=4 and c&gt; 5 and d=6，如果建立（a，b，c，d）顺序的索引，d是无法使用到索引的，但是（a，b，d，c）这种顺序的索引则是可以使用到的，并且a，b，d三者的顺序可以任意调整</code>.</p>
          </blockquote>
        </li>
      </ol>
    </blockquote>
  </li>
</ul>

<h2 id="四存储引擎">四、存储引擎</h2>

<h3 id="1-简介">1. 简介</h3>

<p>​		Mysql中的数据用各种不同的技术存储在文件(或者内存)中，这些技术在存储机制、存储技巧、锁定水平使用不同的技术，最终分别提供了广泛的不同的能力。通过选择不同的技术，能够获得额外的速度或者功能，从而满足不同的应用场景。</p>

<blockquote>
  <p>存储引擎即是:</p>

  <ul>
    <li>如何存储数据;</li>
    <li>如何为存储的数据建立索引;</li>
    <li>如何更新、查询数据等技术的实现方法。</li>
  </ul>
</blockquote>

<h3 id="2-分类">2. 分类</h3>

<p>比较常用的Mysql的存储引擎主要有两种：</p>

<p>​	<strong>InnoDb</strong></p>

<p>​	InnoDb是一种事务型的存储引擎，被很多互联网公司使用，其主要特征为：</p>

<blockquote>
  <ol>
    <li>只有一个聚簇索引，其他的都是非聚簇索引；</li>
    <li>支持行级锁，使用索引时默认使用行级锁，也支持表级锁；</li>
    <li>支持事务；</li>
  </ol>
</blockquote>

<p>​	InnoDb因为引入了行级锁和外键约束，其主要适用于以下场景：</p>

<blockquote>
  <ol>
    <li>数据增删改查都相当的频繁;</li>
    <li>可靠性比较高，存在事务。</li>
  </ol>
</blockquote>

<p>​	<strong>MyISAM</strong></p>

<p>​	MYISAM表是独立与操作系统的，它可以方便的进行数据库移植，其主要特征为：</p>

<blockquote>
  <ol>
    <li>所有的索引都是聚簇索引;</li>
    <li>只支持表级锁，不支持行级锁；</li>
    <li>不支持事务。</li>
  </ol>
</blockquote>

<p>​	因为MYISAM表不支持事务，所以有事务需求的表，不能使用MYISAM的存储引擎，其主要适用于以下几种情况：</p>

<blockquote>
  <ol>
    <li>频繁执行全表count语句;</li>
    <li>对数据记性增删改的频率不高，查询非常频繁；</li>
    <li>没有事务需求。</li>
  </ol>
</blockquote>

<h2 id="五总结">五、总结</h2>

<p>​		本文主要介绍了Mysql如何组织存储数据，索引的结构及常见类型，以及常见的存储引擎。下一篇博文将会总结Mysql的数据库锁以及事务相关知识。</p>
